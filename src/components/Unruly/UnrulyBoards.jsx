//Pregenerated 8x8 boards

const eight = [
    [
        [0, 1, 0, 0, 0, 0, 0, 0],
        [2, 0, 0, 0, 0, 0, 2, 2],
        [0, 0, 0, 1, 0, 0, 0, 2],
        [0, 2, 2, 0, 0, 0, 0, 0],
        [1, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 2, 0, 0],
        [0, 0, 2, 2, 0, 2, 0, 2]
    ],
    [
        [0, 0, 0, 0, 0, 0, 2, 0],
        [0, 1, 0, 0, 0, 0, 2, 1],
        [0, 1, 0, 0, 0, 0, 0, 1],
        [0, 0, 0, 0, 1, 0, 2, 0],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 2, 2, 0, 0, 0],
        [0, 1, 0, 0, 0, 0, 1, 0],
        [1, 0, 1, 0, 0, 1, 0, 0]
    ],
    [
        [1, 0, 1, 0, 2, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 2, 0],
        [0, 0, 1, 1, 0, 0, 2, 0],
        [0, 0, 0, 0, 0, 1, 0, 0],
        [0, 1, 1, 0, 0, 0, 2, 0],
        [0, 0, 0, 0, 0, 1, 0, 0],
        [0, 2, 0, 1, 0, 0, 2, 0],
        [0, 0, 0, 2, 0, 0, 0, 0]
    ],
    [
        [0, 0, 0, 0, 0, 1, 0, 0],
        [1, 1, 0, 0, 1, 0, 1, 0],
        [0, 0, 0, 2, 0, 0, 0, 2],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 2, 0, 0, 0, 2, 0],
        [0, 1, 0, 0, 2, 1, 0, 0],
        [2, 0, 0, 2, 0, 0, 0, 0],
        [2, 0, 2, 0, 0, 0, 0, 1]
    ],
    [
        [2, 1, 0, 0, 0, 2, 0, 0],
        [0, 0, 1, 1, 0, 2, 0, 0],
        [0, 1, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0],
        [1, 0, 2, 0, 0, 1, 1, 0],
        [0, 2, 0, 0, 1, 0, 0, 1],
        [0, 0, 1, 0, 0, 0, 0, 1],
        [2, 0, 0, 0, 0, 0, 0, 0]
    ],
    [
        [0, 0, 1, 0, 1, 0, 1, 0],
        [1, 0, 0, 2, 0, 0, 2, 0],
        [2, 2, 0, 0, 0, 0, 0, 0],
        [0, 1, 0, 0, 0, 1, 0, 0],
        [2, 0, 0, 0, 1, 0, 0, 2],
        [0, 0, 0, 0, 0, 0, 1, 0],
        [0, 1, 0, 0, 0, 0, 0, 2],
        [0, 0, 0, 2, 1, 0, 1, 0]
    ],
    [
        [0, 0, 0, 0, 0, 1, 2, 0],
        [2, 0, 0, 0, 2, 0, 0, 1],
        [0, 1, 1, 0, 0, 0, 2, 0],
        [0, 0, 0, 0, 0, 2, 0, 0],
        [0, 0, 2, 0, 0, 0, 0, 0],
        [0, 2, 2, 0, 0, 0, 0, 2],
        [0, 0, 0, 0, 2, 2, 0, 0],
        [2, 0, 0, 0, 0, 0, 0, 0]
    ],
    [
        [2, 0, 2, 1, 0, 0, 0, 0],
        [0, 1, 0, 0, 0, 0, 0, 0],
        [2, 0, 0, 0, 0, 0, 1, 0],
        [0, 0, 0, 0, 1, 0, 1, 0],
        [0, 1, 0, 0, 0, 0, 0, 0],
        [2, 0, 2, 0, 0, 1, 0, 0],
        [0, 0, 0, 0, 0, 1, 2, 0],
        [0, 0, 0, 0, 1, 0, 1, 1]
    ],
    [
        [0, 2, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 0, 0, 1, 1, 0],
        [0, 0, 1, 0, 1, 0, 0, 0],
        [0, 2, 0, 0, 0, 0, 0, 2],
        [0, 0, 0, 0, 0, 2, 0, 0],
        [1, 1, 0, 0, 2, 0, 0, 0],
        [0, 0, 0, 1, 0, 0, 0, 0],
        [0, 2, 0, 0, 2, 0, 2, 0]
    ],
    [
        [2, 0, 0, 1, 1, 0, 0, 1],
        [0, 0, 0, 1, 0, 0, 0, 0],
        [0, 2, 0, 0, 1, 0, 0, 0],
        [1, 0, 1, 0, 0, 0, 0, 2],
        [0, 0, 0, 0, 0, 0, 0, 2],
        [0, 0, 2, 0, 0, 2, 2, 0],
        [0, 0, 0, 0, 0, 0, 1, 0],
        [0, 1, 0, 0, 0, 2, 0, 0]
    ]
]

function isValidBoard(board) {
    const size = board.length;
    
    // Check rows
    for (let i = 0; i < size; i++) {
        let blackCount = 0;
        let whiteCount = 0;
        let consecutiveCount = 1;
        let lastColor = null;
        
        for (let j = 0; j < size; j++) {
            const color = board[i][j];
            if (color === 1) blackCount++;
            if (color === 2) whiteCount++;
            
            if (color === lastColor && color !== 0) {
                consecutiveCount++;
                if (consecutiveCount > 2) return false;
            } else {
                consecutiveCount = 1;
            }
            lastColor = color;
        }
        
        if (blackCount !== whiteCount) return false;
    }
    
    // Check columns
    for (let j = 0; j < size; j++) {
        let blackCount = 0;
        let whiteCount = 0;
        let consecutiveCount = 1;
        let lastColor = null;
        
        for (let i = 0; i < size; i++) {
            const color = board[i][j];
            if (color === 1) blackCount++;
            if (color === 2) whiteCount++;
            
            if (color === lastColor && color !== 0) {
                consecutiveCount++;
                if (consecutiveCount > 2) return false;
            } else {
                consecutiveCount = 1;
            }
            lastColor = color;
        }
        
        if (blackCount !== whiteCount) return false;
    }
    
    return true;
}

function generateValidBoard(size) {
    const board = Array(size).fill().map(() => Array(size).fill(0));
    const halfSize = Math.floor(size / 2);
    
    // Create initial pattern with alternating colors
    for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
            // Create a checkerboard-like pattern
            if ((i + j) % 2 === 0) {
                board[i][j] = 1; // Black
            } else {
                board[i][j] = 2; // White
            }
        }
    }

    // Randomize while maintaining validity
    for (let attempts = 0; attempts < size * size * 2; attempts++) {
        // Pick two random cells
        const i1 = Math.floor(Math.random() * size);
        const j1 = Math.floor(Math.random() * size);
        const i2 = Math.floor(Math.random() * size);
        const j2 = Math.floor(Math.random() * size);

        // Swap if they're different colors
        if (board[i1][j1] !== board[i2][j2]) {
            [board[i1][j1], board[i2][j2]] = [board[i2][j2], board[i1][j1]];
            
            // Check if the swap created an invalid pattern
            if (!isValidBoard(board)) {
                // Swap back if invalid
                [board[i1][j1], board[i2][j2]] = [board[i2][j2], board[i1][j1]];
            }
        }
    }

    // Clear cells to create the puzzle
    const cellsToClear = Math.floor(size * size * 0.4); // Clear 40% of cells
    const cells = [];
    
    // Create array of all cell positions
    for (let i = 0; i < size; i++) {
        for (let j = 0; j < size; j++) {
            cells.push([i, j]);
        }
    }
    
    // Shuffle cells
    for (let i = cells.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [cells[i], cells[j]] = [cells[j], cells[i]];
    }
    
    // Clear cells
    for (let i = 0; i < cellsToClear; i++) {
        const [row, col] = cells[i];
        board[row][col] = 0;
    }
    
    return board;
}

function generateBoard(size) {
    const generatedBoard = generateValidBoard(size);

    // Add the 'clickable' property to each cell
    const boardWithClickability = generatedBoard.map(row =>
        row.map(cellValue => ({
            value: cellValue,
            clickable: cellValue === 0 // Set clickable to true for value 0 cells
        }))
    );

    return boardWithClickability;
}

export { eight, generateBoard }